# Blockchain-Based E-Voting System - Project Flow & File Explanation

## üéØ PROJECT OVERVIEW
This is a full-stack secure electronic voting system that uses blockchain technology to ensure votes are tamper-proof and transparent. It prevents fraud, double-voting, and allows voters to verify their votes were recorded correctly. The system consists of a Spring Boot backend API and an Angular frontend for a complete user experience.

## üèóÔ∏è PROJECT STRUCTURE & FLOW

### FRONTEND COMPONENTS (Angular)

#### Core Application Files
**File: frontend/src/main.ts**
- **Why made**: Entry point for the Angular application
- **What it does**: Bootstraps the Angular app with necessary providers
- **Simple explanation**: Starts the Angular application and connects it to the browser

**File: frontend/src/app/app.ts**
- **Why made**: Root component of the Angular application
- **What it does**: Main application component that hosts the router outlet
- **Simple explanation**: The main container that holds all other components

**File: frontend/src/app/app.html**
- **Why made**: Template for the root component
- **What it does**: Contains the router outlet for navigation
- **Simple explanation**: The HTML structure that displays different pages

**File: frontend/src/app/app.config.ts**
- **Why made**: Application-wide configuration
- **What it does**: Sets up HTTP client, routing, and other providers
- **Simple explanation**: Configuration hub for the entire Angular app

**File: frontend/src/app/app.routes.ts**
- **Why made**: Defines navigation routes
- **What it does**: Maps URLs to components with guards
- **Simple explanation**: Road map telling Angular which component to show for each URL

#### Authentication & Security
**File: frontend/src/app/auth.ts**
- **Why made**: Handle user authentication operations
- **What it does**: Login, logout, token management, user state
- **Simple explanation**: Authentication manager for the frontend

**File: frontend/src/app/auth-guard.ts**
- **Why made**: Protect routes that require authentication
- **What it does**: Checks if user is logged in before allowing access
- **Simple explanation**: Security guard at the door of protected pages

**File: frontend/src/app/admin-guard.ts**
- **Why made**: Protect admin-only routes
- **What it does**: Ensures only admin users can access admin features
- **Simple explanation**: Special guard for admin-only areas

**File: frontend/src/app/jwt-interceptor.ts**
- **Why made**: Automatically attach JWT tokens to API requests
- **What it does**: Adds authorization headers to HTTP requests
- **Simple explanation**: Automatic token attacher for API calls

#### Services (API Communication)
**File: frontend/src/app/admin.ts**
- **Why made**: Handle admin-related API operations
- **What it does**: User management, election creation, system administration
- **Simple explanation**: Admin API service for backend communication

**File: frontend/src/app/election.ts**
- **Why made**: Manage election data and operations
- **What it does**: Fetch elections, candidates, election status
- **Simple explanation**: Election data manager

**File: frontend/src/app/voting.ts**
- **Why made**: Handle voting operations
- **What it does**: Cast votes, check voting status, retrieve vote history
- **Simple explanation**: Voting operations service

#### UI Components
**File: frontend/src/app/login/**
- **login.ts**: Login component logic - handles user authentication form
- **login.html**: Login form template - username/password inputs and submit button
- **login.css**: Login page styling - makes the login form look good

**File: frontend/src/app/register/**
- **register.ts**: Registration component logic - handles new user signup
- **register.html**: Registration form template - user details form
- **register.css**: Registration page styling - form appearance

**File: frontend/src/app/dashboard/**
- **dashboard.ts**: Dashboard component logic - displays elections and user info
- **dashboard.html**: Dashboard template - shows available elections and navigation
- **dashboard.css**: Dashboard styling - layout and visual design

**File: frontend/src/app/vote/**
- **vote.ts**: Voting component logic - handles candidate selection and vote submission
- **vote.html**: Voting interface template - candidate list with radio buttons
- **vote.css**: Voting page styling - ballot appearance

**File: frontend/src/app/admin/**
- **admin.ts**: Admin panel component logic - manages users and elections
- **admin.html**: Admin interface template - user management and election controls
- **admin.css**: Admin panel styling - administrative interface design

### BACKEND COMPONENTS (Spring Boot)

#### 1. MAIN APPLICATION ENTRY POINT
**File: BlockchainVotingSystemApplication.java**
- **Why made**: This is the starting point of our entire backend application
- **What it does**: Launches the Spring Boot application and enables all the features
- **Simple explanation**: Like the "on" button for our voting system backend - without this, nothing runs

### 2. CONFIGURATION FILES

**File: pom.xml**
- **Why made**: Maven needs this to understand our project and download required libraries
- **What it does**: Lists all dependencies (Spring Boot, database drivers, security libraries, etc.)
- **Simple explanation**: Shopping list of tools our project needs to work

**File: application.properties**
- **Why made**: Contains all settings and configurations
- **What it does**: Database connection details, security keys, server port, blockchain settings
- **Simple explanation**: Control panel with all the knobs and switches for our system

**File: CorsConfig.java**
- **Why made**: Web browsers block requests from different websites for security
- **What it does**: Allows our frontend (web interface) to communicate with our backend
- **Simple explanation**: Permission slip allowing our voting website to talk to the server

**File: SecurityConfig.java**
- **Why made**: Voting systems must be extremely secure
- **What it does**: Sets up JWT authentication, password encryption, and access controls
- **Simple explanation**: Security guard that checks IDs and passwords before allowing access

### 3. DATA MODELS (Database Tables)

**File: User.java**
- **Why made**: We need to store information about voters, admins, and candidates
- **What it does**: Represents user accounts with roles (voter/admin/candidate)
- **Simple explanation**: Profile card for each person using the system

**File: Election.java**
- **Why made**: Elections have specific dates, names, and rules
- **What it does**: Stores election details like start/end dates and descriptions
- **Simple explanation**: Event details for each voting period

**File: Candidate.java**
- **Why made**: People need to know who they're voting for
- **What it does**: Stores candidate information and links them to elections
- **Simple explanation**: Contestant profile in the election

**File: Vote.java**
- **Why made**: We must record every vote securely
- **What it does**: Stores encrypted vote data with blockchain references
- **Simple explanation**: Secure digital ballot box entry

### 4. DATA ACCESS LAYER (Repositories)

**File: UserRepository.java**
- **Why made**: Need to save and find user information in database
- **What it does**: Provides methods to create, read, update, delete users
- **Simple explanation**: Librarian for user data - helps find and store user information

**File: ElectionRepository.java**
- **Why made**: Elections need to be stored and retrieved
- **What it does**: Database operations for election management
- **Simple explanation**: Filing cabinet for election records

**File: CandidateRepository.java**
- **Why made**: Candidates need to be managed in the database
- **What it does**: CRUD operations for candidate data
- **Simple explanation**: Storage system for candidate information

**File: VoteRepository.java**
- **Why made**: Votes are the most critical data - must be stored securely
- **What it does**: Secure storage and retrieval of vote records
- **Simple explanation**: Fort Knox for vote data - extremely secure storage

### 5. BUSINESS LOGIC LAYER (Services)

**File: UserService.java**
- **Why made**: User operations need business rules and validation
- **What it does**: Handles user registration, login, and profile management
- **Simple explanation**: User manager - handles all user-related tasks and rules

**File: ElectionService.java**
- **Why made**: Elections have complex rules (dates, status, etc.)
- **What it does**: Manages election lifecycle and business logic
- **Simple explanation**: Election coordinator - ensures elections run properly

**File: VotingService.java**
- **Why made**: Voting is the core function and must be perfectly secure
- **What it does**: Processes votes, prevents double-voting, records on blockchain
- **Simple explanation**: Vote processor - the heart of the voting system

**File: CustomUserDetailsService.java**
- **Why made**: Spring Security needs to load user details for authentication
- **What it does**: Connects our user database with Spring Security
- **Simple explanation**: Bridge between our users and the security system

### 6. SECURITY COMPONENTS

**File: JwtTokenProvider.java**
- **Why made**: We use JWT tokens for secure authentication
- **What it does**: Creates and validates JWT tokens for user sessions
- **Simple explanation**: Token factory - creates secure access passes for users

**File: JwtAuthenticationFilter.java**
- **Why made**: Every request needs to be checked for valid authentication
- **What it does**: Intercepts requests and validates JWT tokens
- **Simple explanation**: Security checkpoint - checks every visitor has a valid pass

**File: JwtAuthenticationEntryPoint.java**
- **Why made**: Handle unauthorized access attempts gracefully
- **What it does**: Returns proper error messages for failed authentication
- **Simple explanation**: Polite security guard - explains why access was denied

### 7. API CONTROLLERS (REST Endpoints)

**File: AdminController.java**
- **Why made**: Administrators need tools to manage the system
- **What it does**: Provides endpoints for user management and system administration
- **Simple explanation**: Admin control panel - tools for system managers

**File: ElectionController.java**
- **Why made**: Users need to view elections and candidates
- **What it does**: REST endpoints for election and candidate information
- **Simple explanation**: Information booth - provides election details to users

**File: VotingController.java**
- **Why made**: The actual voting process needs API endpoints
- **What it does**: Handles vote submission and retrieval
- **Simple explanation**: Voting booth - where users cast their votes

### 8. DATA TRANSFER OBJECTS (DTOs)

**File: LoginRequest.java**
- **Why made**: Need a standard format for login data
- **What it does**: Carries username and password from client to server
- **Simple explanation**: Login form data container

**File: RegisterRequest.java**
- **Why made**: User registration needs structured data
- **What it does**: Carries new user information during registration
- **Simple explanation**: Registration form data container

### 9. DEVELOPMENT & DEPLOYMENT FILES

**File: README.md**
- **Why made**: Developers and users need to understand the project
- **What it does**: Comprehensive documentation with setup instructions
- **Simple explanation**: User manual and guide for the project

**File: commands.txt**
- **Why made**: Complex setup process needs clear step-by-step instructions
- **What it does**: Lists all commands needed to run the project with explanations
- **Simple explanation**: Recipe book for setting up and running the system

**File: requirements.txt**
- **Why made**: Python development tools need specific versions
- **What it does**: Lists Python packages for development environment
- **Simple explanation**: Shopping list for Python tools

**File: .gitignore**
- **Why made**: Don't want to accidentally commit sensitive or unnecessary files
- **What it does**: Tells Git which files to ignore (passwords, build files, etc.)
- **Simple explanation**: Filter that keeps secret and temporary files out of the repository

## üîÑ HOW THE FULL-STACK SYSTEM WORKS (Complete Flow)

### Frontend-Backend Integration Overview:
1. **Angular Frontend** runs on `http://localhost:4200` - provides user interface
2. **Spring Boot Backend** runs on `http://localhost:8080` - provides API endpoints
3. Frontend makes HTTP requests to backend APIs for data and operations
4. JWT tokens handle authentication between frontend and backend

### Complete User Journey:

#### User Registration Flow:
1. **Frontend**: User fills registration form in `register.html` ‚Üí `register.ts` handles form submission
2. **Frontend**: `register.ts` calls `auth.ts` service ‚Üí makes HTTP POST to `/api/auth/register`
3. **Backend**: Request reaches `AuthController.java` ‚Üí validates RegisterRequest.java
4. **Backend**: Controller calls `UserService.java` ‚Üí validates business rules
5. **Backend**: Service calls `UserRepository.java` ‚Üí saves to database (User.java model)
6. **Backend**: Password encrypted by `SecurityConfig.java` using BCrypt
7. **Frontend**: User redirected to login page on successful registration

#### Authentication Flow:
1. **Frontend**: User enters credentials in `login.html` ‚Üí `login.ts` handles form
2. **Frontend**: `login.ts` calls `auth.ts` ‚Üí HTTP POST to `/api/auth/login`
3. **Backend**: Request to `AuthController.java` ‚Üí validates LoginRequest.java
4. **Backend**: `CustomUserDetailsService.java` loads user from database
5. **Backend**: `JwtTokenProvider.java` creates JWT token with user claims
6. **Frontend**: Token stored in localStorage, user redirected to dashboard
7. **Frontend**: `jwt-interceptor.ts` automatically adds token to future API calls

#### Election Viewing Flow:
1. **Frontend**: User navigates to dashboard ‚Üí `dashboard.ts` loads on component init
2. **Frontend**: `dashboard.ts` calls `election.ts` service ‚Üí GET `/api/elections/active`
3. **Backend**: `ElectionController.java` receives request ‚Üí calls `ElectionService.java`
4. **Backend**: Service queries `ElectionRepository.java` ‚Üí returns active elections
5. **Frontend**: Elections displayed in `dashboard.html` with voting buttons

#### Voting Flow:
1. **Frontend**: User clicks "Vote" ‚Üí navigates to `/vote/:electionId` route
2. **Frontend**: `vote.ts` loads ‚Üí calls `election.ts` for candidates ‚Üí GET `/api/elections/{id}/candidates`
3. **Backend**: `ElectionController.java` ‚Üí `ElectionService.java` ‚Üí `CandidateRepository.java`
4. **Frontend**: User selects candidate in `vote.html` ‚Üí submits vote
5. **Frontend**: `vote.ts` calls `voting.ts` service ‚Üí POST `/api/voting/vote`
6. **Backend**: `VotingController.java` validates request ‚Üí calls `VotingService.java`
7. **Backend**: Service checks for double-voting using `VoteRepository.java`
8. **Backend**: Vote saved to database ‚Üí blockchain recording (future feature)
9. **Frontend**: Success message shown, user redirected to dashboard

#### Admin Management Flow:
1. **Frontend**: Admin logs in ‚Üí `admin-guard.ts` allows access to `/admin` route
2. **Frontend**: `admin.ts` component loads ‚Üí calls services for users and elections
3. **Frontend**: Admin can create users via `admin.ts` service ‚Üí POST `/api/admin/users`
4. **Backend**: `AdminController.java` ‚Üí `UserService.java` ‚Üí `UserRepository.java`
5. **Frontend**: Admin creates elections ‚Üí POST `/api/admin/elections`
6. **Backend**: `ElectionService.java` saves election and candidates
7. **Frontend**: Admin toggles election status ‚Üí PUT `/api/admin/elections/{id}/activate`

### Security Flow (End-to-End):
1. **Frontend**: All API calls pass through `jwt-interceptor.ts` ‚Üí adds Authorization header
2. **Backend**: Every request filtered by `JwtAuthenticationFilter.java`
3. **Backend**: Filter validates JWT using `JwtTokenProvider.java`
4. **Backend**: Invalid tokens rejected by `JwtAuthenticationEntryPoint.java`
5. **Backend**: Valid requests proceed with user context from `SecurityContext`
6. **Backend**: Controllers check roles using `@PreAuthorize` annotations
7. **Frontend**: Route guards (`auth-guard.ts`, `admin-guard.ts`) protect client-side routes

### Data Flow Architecture:
- **Frontend Services** (`auth.ts`, `election.ts`, `voting.ts`, `admin.ts`) ‚Üí HTTP calls to backend
- **Backend Controllers** ‚Üí Receive requests, delegate to services
- **Backend Services** ‚Üí Business logic, validation, call repositories
- **Backend Repositories** ‚Üí Database operations using JPA/Hibernate
- **Database** ‚Üí PostgreSQL stores all application data
- **Security Layer** ‚Üí JWT tokens, BCrypt passwords, role-based access control

## üéØ WHY BLOCKCHAIN?

The blockchain integration (planned for future) will:
- Make votes immutable (can't be changed)
- Provide transparency (anyone can verify results)
- Prevent tampering (cryptographic security)
- Enable vote verification (users can check their vote was recorded)

## üöÄ DEPLOYMENT FLOW

### Development Environment Setup:
1. **Backend Setup**: Use `commands.txt` to configure PostgreSQL database and run Spring Boot
2. **Frontend Setup**: Navigate to `frontend/` directory, run `npm install`, then `ng serve`
3. **Database**: PostgreSQL creates tables automatically from JPA entity models
4. **Ports**: Backend on `http://localhost:8080`, Frontend on `http://localhost:4200`

### Production Deployment:
1. **Backend Build**: `mvn clean package -DskipTests` creates JAR file
2. **Frontend Build**: `ng build --configuration production` creates optimized dist/
3. **Database**: Configure production PostgreSQL instance with environment variables
4. **Security**: Set JWT_SECRET and database credentials as environment variables
5. **Deployment**: Deploy JAR to server, serve Angular dist/ files via web server
6. **Reverse Proxy**: Nginx/Apache to route `/api/*` to backend and `/*` to frontend

### Docker Deployment (Recommended):
```dockerfile
# Backend Dockerfile
FROM openjdk:17-jdk-alpine
COPY target/*.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java","-jar","/app.jar"]

# Frontend Dockerfile
FROM nginx:alpine
COPY dist/frontend /usr/share/nginx/html
EXPOSE 80
```

### Environment Variables:
```bash
# Backend
SPRING_DATASOURCE_URL=jdbc:postgresql://prod-db:5432/evoting_db
SPRING_DATASOURCE_USERNAME=prod_user
SPRING_DATASOURCE_PASSWORD=secure_password
JWT_SECRET=your_production_jwt_secret
SPRING_PROFILES_ACTIVE=prod

# Frontend (build time)
API_BASE_URL=https://your-api-domain.com/api
```

This full-stack project follows clean architecture principles with clear separation of concerns between frontend and backend, making it maintainable, secure, and scalable for real-world electronic voting systems. The Angular frontend provides a modern, responsive user interface while the Spring Boot backend ensures robust API functionality and data security.
